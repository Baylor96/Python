0. 下边只有一种方式不能打开文件，请问是哪一种，为什么？
>>> f = open('E:/test.txt', 'w')   # A
>>> f = open('E:\test.txt', 'w')   # B
>>> f = open('E://test.txt', 'w')  # C
>>> f = open('E:\\test.txt', 'w')  # D

答：B不能打开文件。

Windows在路径名中既可以接受斜线（/）也可以接受反斜线（\），不过如果使用反斜线作为路径名的分隔符的话，要注意使用双反斜线（\\）进行转义，否
则Python会将反斜线进行转义，例如（\n）看成一个换行符，（\t）看作一个制表符等。


1. 打开一个文件我们使用open()函数，通过设置文件的打开模式，决定打开的文件具有那些性质，请问默认的打开模式是什么呢？

答：open()函数默认的打开模式是'rt'，即可读、文本的模式打开。


2. 请问 >>> open('E:\\Test.bin', 'xb') 是以什么样的模式打开文件的？

答：以“可写入以及二进制模式”打开文件“E:\\Test.bin”。

这里要注意的是'x'和'w'均是以“可写入”的模式打开文件，但以'x'模式打开的时候，如果路径下已经存在相同的文件名，会抛出异常，而'w'模式的话会直
接覆盖同名文件。

因此，'w'模式打开文件会比较危险，容易导致此前的内容遗失，因此使用'w'模式打开文件前先检查该文件名是否已经存在显得非常重要！下节课小甲鱼会
教你如何安全的打开一个文件^_^


3. 尽管Python有所谓的“垃圾回收机制”，但对于打开了的文件，在不需要用到的时候我们仍然需要使用f.close()将文件对象“关闭”，这是为什么呢？

答：Python拥有垃圾收集机制，会在文件对象的引用计数降至零的时候自动关闭文件，所以在Python编程里，如果忘记关闭文件并不会造成内存泄漏那么危
险。但并不是说就可以不要关闭文件，如果你对文件进行了写入操作，那么你应该在完成写入之后进行关闭文件。因为Python可能会缓存你写入的数据，如果这中
间断电了神马的，那些缓存的数据根本就不会写入到文件中。所以，为了安全起见，要养成使用完文件后立刻关闭的优雅习惯。

4. 如何将一个文件对象（f）中的数据存放进列表中？

答：list(f)，是不是非常的方便！

5. 如何迭代打印出文件对象（f）中的每一行数据？

答：直接使用for语句把文件对象迭代出来即可：
for each_line in f:
        print(each_line)

6. 文件对象的内置方法f.read([size=-1])作用是读取文件对象内容，size参数是可选的，那如果设置了size=10，例如f.read(10)，将返回什么内容呢？

答：将返回从文件指针开始（注意这里并不是文件头哦）的连续10个字符。

7. 如何获得文件对象（f）当前文件指针的位置？

答：f.tell()会告诉你^_^


8. 还是视频中的那个演示文件（record.txt），请问为何f.seek(45, 0)不会出错，但f.seek(46)就出错了呢？
>>> f.seek(46)
46
>>> f.readline()
Traceback (most recent call last):
  File "<pyshell#18>", line 1, in <module>
    f.readline()
UnicodeDecodeError: 'gbk' codec can't decode byte 0xe3 in position 4: illegal multibyte sequence

答：因为使用f.seek()定位的文件指针是按字节为单位进行计算的，演示文件（record.txt）是以GBK进行编码的，按照规则，一个汉字需要占用两个字节，
f.seek(45)的位置位于字符“小”的开始位置，因此可以正常打印，而f.seek(46)的位置刚好位于字符“小”的中间位置，因此按照GBK编码的形式无法将其解
码！